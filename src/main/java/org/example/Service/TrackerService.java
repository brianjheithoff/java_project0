package org.example.Service;

import org.example.Exception.TrackerException;
import org.example.Main;
import org.example.Model.Tracker;

import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;

public class TrackerService {

    List<Tracker> trackers;
    public TrackerService(){
        trackers = new ArrayList<>();
    }

    /**
     * I don't intend to add timestamp as a parameter to the method -
     * I know I will ask the user for title, instructions
     * I plan for timestamp to be auto-generated by the program.
     * @param name
     * @param details
     */
    public void addTracker(String name, String details, int distance) throws TrackerException {
        Main.log.info("Attempting to add a recipe." + name +", " +details +", " + distance);
        Timestamp currentTime = new Timestamp(System.currentTimeMillis());
        if(distance < 1){
            Main.log.warn("throwing recipe exception due to misformatted servings: "+distance);
            throw new TrackerException("servings must be at least 1 when adding a recipe");
        }else if (name.length()<1){
            Main.log.warn("throwing recipe exception due to misformatted title: "+name);
            throw new TrackerException("title is blank");
        }else if(details.length()<1){
            Main.log.warn("throwing recipe exception due to misformatted instructions: "+details);
            throw new TrackerException("instructions is blank");
        }
        Tracker r = new Tracker(name, details, distance, currentTime);
        trackers.add(r);
    }
    public void addTracker(String name, String details, int distance, Timestamp time){
        Tracker r = new Tracker(name, details, distance, time);
        trackers.add(r);
    }
    public List<Tracker> getAllTracker(){
        Main.log.info("Now retrieving all recipes: "+trackers);
        return trackers;
    }

    /**
     * Let's say that we would like to get all of a recipe's information
     * just using their title
     * [{pasta, instruction1, 1}, {scrambled egg, instructions2, 1}, {cake, instructions3, 1}
     * .. {chicken soup, instructions100, 1}]
     *
     * "How would you describe to a human how to solve a problem using a very large input (100+ items)"
     * (pencil and paper)
     * pseudocode - describing the process through regular language, but formatted like a programming
     * routine
     * look through the entire list
     *      every item should be checked for its title
     *          if the item matches what we're looking for, let's "return"
     * if we've looked through the entire list and we haven't found our item yet, then we'll
     * say that we don't have the item ("return null" or throw an exception)
     *
     * or, if we want to return multiple items with the same title
     * set up a list for all the recipes with the same name
     * look through the entire list
     *      every item should be checked for its title
     *          if the item matches what we're looking for, let's add that item to the list of matches
     * after we're done looking through the list, return the list
     *
     * A for loop can allow us to look at what every item in a collection is.
     * An if statement can allow us to check if a value matches.
     * Return will produce a result.
     *
     * Algorithm : a set of steps that will always produce a specific
     * answer given a certain input.
     * "linear search"
     */
    public Tracker getTrackerByName(String name){
//        a for loop intended to search through an entire list
//        (extremely standard - however, it is possible to start 'i' at any value)
//        every run of the loop will verify that the second part of the statement is true prior to running
//        every run of the loop will increment this variable i by 1 - however, this can be changed
        for(int i = 0; i < trackers.size(); i=i+1){
//            obtain the recipe at the i position
            Tracker currentTracker = trackers.get(i);
//            check the recipe at the i position for its title
            if(currentTracker.getName().equals(name)){
//                if we find a match , return the match
                return currentTracker;
            }
        }
        return null;
    }
}

